破坏单例的方式：

1、多线程下不安全
获取单例时，存有竞争条件，多线程下有可能导致创建多个实例
解决方法：
    加锁；
    采取饿汉式单例（静态常量）、枚举单例（JDK保证）、懒汉式的静态内部类单例，不用加锁也可安全

2、反射攻击
通过反射机制，获得构造方法，强制实例化，可获得多个实例
解决方法：
    在默认构造函数中处理控制，如果已经创建过，则抛出异常，如：懒汉式的静态内部类单例；
    设置成静态常量，如懒汉式、枚举单例

3、序列化破坏单例
反序列化后的对象会重新分配内存，即重新创建。
解决方法：
    根据JDK源码可知，通过重写readResolve()就可以避免，缺点：内存分配开销增大；
    枚举类型在JDK的语法特殊性，无法通过反射进行实例化

在通过双重检查锁方式创建单例时，如果静态变量不加volatile关键词修饰，由于内存指令重排序的存在，有可能导致获取到一个分配了地址，但还未初始化的单例，即半个单例

